代码如下：
[code=java]
#[Tags]/* 在BC31下编译 或VC6.0*/
#[Tags]/* compile under Borland C++ 3.1 or Visual C++ 6.0*/
#[Tags]/*#include #[Fields]"stdafx.h"#*/
#include #[Fields]"stdio.h
#include #[Fields]"string.h
#include #[Fields]"stdlib.h
#include #[Fields]"conio.h
#define TRUE 1
#define FALSE 0
#define STACK_INIT_SIZE 100#[Tags]/*存储空间初始分配量*/
#define STACKINCREMENT 20#[Tags]/*存储空间分配增量*/
typedef struct
{
	#[Keywords]int #*pBase;#[Tags]/*在构造之前和销毁之后,base的值为NULL*/
	#[Keywords]int #*pTop;#[Tags]/*栈顶指针*/
	#[Keywords]int #StackSize;#[Tags]/*当前已分配的存储空间,以元素为单位*/
#}Stack;
typedef #[Keywords]int #BOOLEAN;
#[Keywords]char #Operator[8]=#[Fields]"+-*/()#"#;#[Tags]/*合法的操作符存储在字符串中*/
#[Keywords]char #Optr;#[Tags]/*操作符*/
#[Keywords]int #Opnd=-1;#[Tags]/*操作符*/
#[Keywords]int #Result;#[Tags]/*操作结果*/
#[Tags]/*算符间的优先关系*/
#[Keywords]char #PriorityTable[7][7]=
{
	#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},
	#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},
	#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},
	#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'<'#,#[Fields]'>'#,#[Fields]'>'##},
	#{#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'='#,#[Fields]'o'##},
	#{#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'>'#,#[Fields]'o'#,#[Fields]'>'#,#[Fields]'>'##},
	#{#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'<'#,#[Fields]'o'#,#[Fields]'='##},
#};
#[Comments]//数据对象的操作方法
#[Comments]//构造一个空栈,如果返回值为0,则表示初始化失败
Stack InitStack()/*这是个效率低的方法*/
{
	#Stack S;
	#S.pBase=(int*)malloc(STACK_INIT_SIZE*sizeof(#[Keywords]int#));
	#[Keywords]if#(!S.pBase)
	#{#[Tags]/*内存分配失败*/
		#printf(#[Fields]"内存分配失败,程序中止运行\n"#);
		#exit(-1);
	#}
	#else
	#{
		#S.pTop=S.pBase;
		#S.StackSize=STACK_INIT_SIZE;
	#}
	#[Keywords]return #S;
#}
#[Comments]//销毁栈S,S不再存在
#[Keywords]void #DestoryStack(Stack *S)
{
	#[Keywords]if#(S->pBase)
	#{
		#free(S->pBase);
		#S->pTop=S->pBase=NULL;
        
	#}
#}
#[Comments]//若栈不空,则用e返回S的栈顶元素
#[Comments]//注:由于应用的特殊,可以不检查栈是否为空
#[Keywords]int #GetTop(Stack S)
{
	#[Keywords]return #*(S.pTop-1);
#}
#[Comments]//插入元素e为新的栈顶元素,如果成功则返回1,否则返回0
#[Keywords]int #Push(Stack *S,#[Keywords]int #e)
{
	#[Keywords]if#(S->pTop-S->pBase==S->StackSize)
	#{#[Comments]//栈满,追加存储空间
		#S->pBase=(int*)realloc(S->pBase,S->StackSize+STACKINCREMENT*sizeof(#[Keywords]int#));
		#[Keywords]if#(!S->pBase)
			#[Keywords]return #0;#[Comments]//存储分配失败
		#S->pTop=S->pBase+S->StackSize;
		#S->StackSize+=STACKINCREMENT;
	#}
	#[Tags]*(S->pTop++)=e;
	#[Keywords]return #1;
#}
#[Keywords]int #Pop(Stack *S,#[Keywords]int #*e)
{#[Comments]//若栈不空,则删除S的栈顶元素,用e 返回其值,并返回1;否则返回0
	#[Keywords]if#(S->pTop==S->pBase)
		#[Keywords]return #0;
	#[Tags]*e=#[Tags]*--(S->pTop);
	#[Keywords]return #1;

#}
#[Comments]//主函数及其它函数的实现
#[Comments]//比较两个数学符号operator_1,operator_2的计算优先权,在算符优先关系表中查找相应的关系并返回'<','=',或'>'
#[Keywords]char #CheckPriority(#[Keywords]char #operator_1,#[Keywords]char #operator_2)
{
	#[Keywords]int #i,j;#[Comments]//用来查询算符间优先关系表的下标
	#[Comments]//char *ptr;
	#i=strchr(Operator,operator_1)-Operator;#[Comments]//找到传入操作符在字符串Operators中的相对位置
	#j=strchr(Operator,operator_2)-Operator;
	#[Comments]//返回算符优先关系表中相应值
	#[Keywords]return #PriorityTable[i][j];
#}
BOOLEAN IsOperator(#[Keywords]char #ch)
{#[Comments]//判断一个字符是否为打操作符
	#[Keywords]if#(strchr(Operator,ch))
		#[Keywords]return #TRUE;
	#[Keywords]else #
		#[Keywords]return #FALSE;

#}
#[Comments]//从键盘获得输入
#[Keywords]void #GetInput(void)
{
	#[Keywords]char #Buffer[20];#[Comments]//键盘输入缓冲区,用来处理输入多位数的情况
	#[Keywords]char #ch;#[Comments]//存放键盘输入
	#[Keywords]int #index;#[Comments]//存放Buffer的下标
	#index=0;
	#ch=getch();#[Comments]//从键盘读入一个字符
	#[Keywords]while#(ch!=13&&!IsOperator(ch))
	#{#[Comments]//如果输入的字符是回车符或是操作符,循环结束
		#[Keywords]if#(ch>=#[Fields]'0'#&&ch<=#[Fields]'9'#)
		#{#[Comments]//将字符回显到屏幕
			#printf(#[Fields]"%c"#,ch);
			#Buffer[index]=ch;
			#index++;

		#}
		#ch=getch();
	#}
	#[Keywords]if#(ch==13)
		#Optr=#[Fields]'#'#;#[Comments]//输入的表达式以回车符结束
	#else
	#{
		#Optr=ch;
		#printf(#[Fields]"%c"#,ch);

	#}
	#[Keywords]if#(index>0)
	#{
		#Buffer[index]=#[Fields]'\0'#;
		#Opnd=atoi((Buffer));
	#}
	#else
		#Opnd=-1;#[Comments]//程序不支持输入负数,当Opnd为负数时,表示输入的字符为操作符
#}
#[Comments]//计算形如a+b之类的表达式,theta为操作符,a,b为操作数
#[Keywords]int #Calc(#[Keywords]int #a,#[Keywords]char #theta,#[Keywords]int #b)
{
	#switch(theta)
	#{
	#[Keywords]case ##[Fields]'+'#:
		#[Keywords]return #a+b;
	#[Keywords]case ##[Fields]'-'#:
		#[Keywords]return #a-b;
	#[Keywords]case ##[Fields]'*'#:
		#[Keywords]return #a*b;
	#[Keywords]default#:
		#[Keywords]if#(b==0)#[Comments]//除数为零的情况
		#{
			#printf(#[Fields]"除数不能为"#);
			#[Keywords]return #0;#[Comments]//返回0用以显示
		#}
		#else
			#[Keywords]return #a/b;
	#}
#}
#[Tags]/*表达式求值*/
BOOLEAN EvaluateExpression()
{
	#[Keywords]int #temp;#[Comments]//临时变量
	#[Keywords]char #theta;#[Comments]//存放操作符的变量
	#[Keywords]int #itheta;#[Comments]//存放出栈的操作符的变量add by me
	#[Keywords]int #a,b;#[Comments]//存放表达式运算时的中间值
	#[Keywords]int #topOpnd;#[Comments]//栈顶操作数
	#[Keywords]char #topOptr;#[Comments]//栈顶操作符
	
	#Stack OPTR=InitStack();#[Comments]//操作符栈
	#Stack OPND=InitStack();#[Comments]//操作数栈

	#[Keywords]if#(!Push(&OPTR,#[Fields]'#'#))#[Comments]//操作符栈中的第一个为#字符
		#[Keywords]return #FALSE;

	#GetInput();#[Comments]//从键盘获得输入

	#[Keywords]while#(Optr!=#[Fields]'#'#||GetTop(OPTR)!=#[Fields]'#'#)
	#{#[Comments]//如果Optr>=0,表示有操作数输入
		#[Keywords]if#(Opnd>=0)Push(&OPND,Opnd);
		#switch(CheckPriority(GetTop(OPTR),Optr))
		#{
		#[Keywords]case ##[Fields]'<'#:#[Comments]//栈顶元素优先权低
			#[Keywords]if#(!Push(&OPTR,Optr))#[Keywords]return #FALSE;
				#GetInput();
			#[Keywords]break#;
		#[Keywords]case ##[Fields]'='#:#[Comments]//脱括号并接收键盘输入
			#Pop(&OPTR,&temp);GetInput();
			#[Keywords]break#;
		#[Keywords]case ##[Fields]'>'#:#[Comments]//退栈并将运算结果入栈
			#[Comments]//先用itheta得到操作符在赋给theta
			#Pop(&OPTR,&itheta);
			#Pop(&OPND,&b);
			#Pop(&OPND,&a);
			#theta = (char)( itheta );
			#Push(&OPND,Calc(a,itheta,b));
			#Opnd=-1;
			#[Keywords]break#;

		#}
	#}
	#[Comments]//本算法中,当输入只有一个操作数然后就输入回车符时,
	#[Comments]//OPND.pTop==OPND.pBase
	#[Comments]//如果OPND.pTop==OPND.pBase并且Opnd<0,则说明用户
	#[Comments]//未输入任何操作和操作符而直接输入[回车],程序直接
	#[Comments]//退出运行
	#[Keywords]if#(OPND.pTop==OPND.pBase&&Opnd<0)
	#{
		#printf(#[Fields]"\n\n感谢使用!\n"#);
		#exit(1);

	#}
	#[Keywords]else #[Keywords]if#(OPND.pTop==OPND.pBase)
		#Result=Opnd;
	#else
	#{
		#Result=GetTop(OPND);
		#DestoryStack(&OPND);
		#DestoryStack(&OPTR);
	#}
	#[Keywords]return #TRUE;

#}

#[Keywords]void #Message(void)
{
	#printf(#[Fields]"\n四则运算表达式求值演示\n"#);
	#printf(#[Fields]"-------------------------------\n"#);
	#printf(#[Fields]"使用方法:请从键盘上直接输入表达式,以回车键结束.如45*(12-2)[回车]\n"#);
	#printf(#[Fields]"注0:不输入任何数而直接按[回车]键,将退出程序.\n"#);
	#printf(#[Fields]"注1:本程序暂时不接受除数字键及四则运算符之外的任何其它键盘输入.\n"#);
	#printf(#[Fields]"注2:本程序暂时只能处理正确的表达式,不支持输入负数.\n"#);
	#printf(#[Fields]"-------------------------------\n\n"#);
#}
#[Keywords]void #main(void)
{
	#[Keywords]int #i;#[Comments]//用来一些说明性信息
	#Message();
	#[Keywords]for#(i=1;;i++)
	#{
		#printf(#[Fields]"表达式%d:"#,i);
		#[Keywords]if#(EvaluateExpression())
			#printf(#[Fields]"=%d\n"#,Result);
		#else
			#printf(#[Fields]"计算中遇到错误\n"#);
		
	#}
#}
[/code]