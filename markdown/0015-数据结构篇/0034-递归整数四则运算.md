代码如下：
[code=java]
#[Tags]/* 在BC31下编译 */
#[Tags]/* compile under Borland C++ 3.1 */
#[Tags]/*
#[Tags]对四则混合运算所提取的形式化表达式(生成式)
#[Tags]<exp> -> <term> { <addop> <term> #}
#[Tags]<addop> -> + | -
#[Tags]<term> -> <factor> { <mulop> <factor> #}
#[Tags]<mulop> -> * | /
#[Tags]<factor> -> ( <exp> ) | Number
#[Tags]*/
#include <stdio.h>
#include <stdlib.h>
#[Keywords]char #token; #[Tags]/*全局标志变量*/
#[Tags]/*递归调用的函数原型*/
#[Keywords]int #exp( #[Keywords]void #);
#[Keywords]int #term( #[Keywords]void #);
#[Keywords]int #factor( #[Keywords]void #);
#[Keywords]void #error( #[Keywords]void #) /*报告出错信息的函数*/
{
	#fprintf( stderr, #[Fields]"错误\n"#);
	#exit( 1 );
#}
#[Keywords]void #match( #[Keywords]char #expectedToken ) #[Tags]/*对当前的标志进行匹配*/
{
	#[Keywords]if#( token == expectedToken ) token = getchar(); #[Tags]/*匹配成功，获取下一个标志*/
	#[Keywords]else #error(); #[Tags]/*匹配不成功，报告错误*/
#}
#[Keywords]void #Message(void)
{
	#printf(#[Fields]"================================================================\n"#);
	#printf(#[Fields]"*               递归实现的四则运算表达式求值程序               *\n"#);
	#printf(#[Fields]"****************************************************************\n"#);
	#printf(#[Fields]"使用方法:请从键盘上直接输入表达式,以回车键结束.如45*(12-2)[回车]\n"#);
	#printf(#[Fields]"*****************************************************************\n\n"#);
#}
main()
{
	#[Keywords]int #result;  #[Tags]/*运算的结果*/
	#Message();
	#printf(#[Fields]" >> 请输入表达式: "#);
	#token = getchar(); #[Tags]/*载入第一个符号*/
	
	#result = exp(); #[Tags]/*进行计算*/
	#[Keywords]if#( token == #[Fields]'\n'# ) #[Tags]/* 是否一行结束 */
		#printf( #[Fields]" >> 表达式的计算结果为 : %d\n"#, result );
	#[Keywords]else #error(); #[Tags]/* 出现了例外的字符 */
	#puts(#[Fields]"\n\n                  请按任意键退出 ...\n"#);
	#getch();
	#[Keywords]return #0;
#}
#[Keywords]int #exp( #[Keywords]void #)
{
	#[Keywords]int #temp = term(); /*计算比加减运算优先级别高的部分*/
	#[Keywords]while#(( token == #[Fields]'+'# ) || ( token == #[Fields]'-'# ))
		#switch( token ) {
		#[Keywords]case ##[Fields]'+'#: match(#[Fields]'+'#);     /*加法*/
			  #temp += term();
			  #[Keywords]break#;
		#[Keywords]case ##[Fields]'-'#: match(#[Fields]'-'#);
			  #temp -= term(); #[Tags]/*减法*/
			  #[Keywords]break#;
		#}
	#[Keywords]return #temp;
#}
#[Keywords]int #term( #[Keywords]void #)
{
	#[Keywords]int #div; #[Tags]/*除数*/
	#[Keywords]int #temp = factor();   #[Tags]/*计算比乘除运算优先级别高的部分*/
	#[Keywords]while#(( token == #[Fields]'*'# ) || ( token == #[Fields]'/'# ))
		#switch( token ) {
		#[Keywords]case ##[Fields]'*'#: match(#[Fields]'*'#);  #[Tags]/*乘法*/
			  #temp *= factor();
			  #[Keywords]break#;
		#[Keywords]case ##[Fields]'/'#: match(#[Fields]'/'#);   #[Tags]/*除法*/
			  #div = factor();
			  #[Keywords]if#( div == 0 ) #[Tags]/*需要判断除数是否为0*/
			  #{
			  	#fprintf( stderr, #[Fields]"除数为0.\n"# );
			  	#exit(1);
			  #}
			  #temp /= div;
			  #[Keywords]break#;
		#}
	#[Keywords]return #temp;
#}
#[Keywords]int #factor( #[Keywords]void #)
{
	#[Keywords]int #temp; 
	#[Keywords]if#( token == #[Fields]'('# ) #[Tags]/*带有括号的运算*/
	#{
		#match( #[Fields]'('# );
		#temp = exp();
		#match(#[Fields]')'#);
	#}
	#[Keywords]else #[Keywords]if #( isdigit( token )) #[Tags]/*实际的数字*/
	#{
		#ungetc( token, stdin ); #[Tags]/*将读入的字符退还给输入流*/
		#scanf( #[Fields]"%d"#, &temp ); #[Tags]/*读出数字*/
		#token = getchar();  #[Tags]/*读出当前的标志*/
	#}
	#[Keywords]else #error(); #[Tags]/*不是括号也不是数字*/
	#[Keywords]return #temp;
#}
[/code]