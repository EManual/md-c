代码如下：
[code=java]
#include<stdio.h>
#include<math.h>
#[Keywords]int #number[210][5];
#[Tags]/*存放可逆素数及素数分解后的各位数字*/
#[Keywords]int #select[110];
#[Tags]/*可以放在矩阵第一行和最后一行的素数的下标*/
#[Keywords]int #array[4][5];
#[Tags]/*4X4的矩阵，每行0号元素存可逆素数对应的数组下标*/
#[Keywords]int #count ;
#[Tags]/*可逆素数的数目*/
#[Keywords]int #selecount ;
#[Tags]/*可以放在矩阵第一行和最后一行的可逆素数的数目*/
#[Keywords]int #larray[2][200];
#[Tags]/*存放素数前二、三位数的临时数组所对应的数量计数器*/
#[Keywords]int #lcount[2];
#[Keywords]int #num(#[Keywords]int #number);
#[Keywords]int #ok(#[Keywords]int #number);
#[Keywords]void #process(#[Keywords]int #i);
#[Keywords]void #copy_num(#[Keywords]int #i);
#[Keywords]int #comp_num(#[Keywords]int #n);
#[Keywords]int #find1(#[Keywords]int #i);
#[Keywords]int #find2(void);
#[Keywords]int #find0(#[Keywords]int #num);
#[Keywords]void #p_array(void);
FILE*fp ;
#[Keywords]void #main()
{
    #[Keywords]int #i,k,flag,cc=0,i1,i4 ;
    #clrscr();
    #[Keywords]if#((fp=fopen(#[Fields]"Exa70data.dat"#,#[Fields]"w+"#))==NULL)
    #{
        #printf(#[Fields]"\n Can#[Fields]'t create file Exa70data.dat !\n"#);
        #exit(0);
    #}
    #printf(#[Fields]"there are magic squares with invertable primes as follw:\n"#);
    #/*求满足条件的可逆素数*/
    #[Keywords]for#(i=1001;i<9999;i+=2)
    #{
        #k=i/1000 ;
        #/*若可逆素数的第一位不是偶数或5*/
        #[Keywords]if#(k%2!=0&&k!=5&&num(i))
        #{
            #number[count][0]=i ;
            #/*存入数组*/
            #process(count++);
            #/*分解素数的各位数字*/
            #/*若可逆素数满足放在矩阵第一行*/
            #/*和最后一行的条件，记录可逆素数的*/
            #/*下标，计数器加1*/
            #[Keywords]if#(number[count-1][2]%2!=0&&number[count-1][3]%2!=0&&number[count-1][2]!=5&&number[count-1][3]!=5)
            #select[selecount++]=count-1 ;
        #}
    #}
    #larray[0][lcount[0]++]=number[0][0]/100 ;
    #/*临时数组的第一行存前二位*/
    #larray[1][lcount[1]++]=number[0][0]/10 ;
    #/*临时数组的第二行存前三位*/
    #/*将素数不重复的前二、三位存入临时数组中*/
    #[Keywords]for#(i=1;i<count;i++)
    #{
        #[Keywords]if#(larray[0][lcount[0]-1]!=number[i][0]/100)
        #larray[0][lcount[0]++]=number[i][0]/100 ;
        #[Keywords]if#(larray[1][lcount[1]-1]!=number[i][0]/10)
        #larray[1][lcount[1]++]=number[i][0]/10 ;
    #}
    #/*在第一行允许的汇聚围内穷举*/
    #[Keywords]for#(i1=0;i1<selecount;i1++)
    #{
        #array[0][0]=select[i1];
        #[Tags]/*取对应的素数下标*/
        #copy_num(0);
        #[Tags]/*复制分解的素数*/
        #[Tags]/*穷举第二行*/
        #[Keywords]for#(array[1][0]=0;array[1][0]<count;array[1][0]++)
        #{
            #copy_num(1);
            #[Tags]/*复制分解的数字*/
            #[Keywords]if#(!comp_num(2))
            #[Keywords]continue# ;
            #[Tags]/*若每列的前两位的组成与素数相矛盾，则试探下一个数*/
            #[Tags]/*穷举第三行*/
            #[Keywords]for#(array[2][0]=0;array[2][0]<count;array[2][0]++)
            #{
                #copy_num(2);
                #[Tags]/*复制分解的数字*/
                #[Keywords]if#(!comp_num(3))
                #[Keywords]continue# ;
                #[Tags]/*若每列的前三位的组成与素数相矛盾，则试探下一个数*/
                #[Tags]/*在最后一行允许的范围内穷举*/
                #[Keywords]for#(i4=0;i4<selecount;i4++)
                #{
                    #array[3][0]=select[i4];
                    #copy_num(3);
                    #[Tags]/*复制分解的数字*/
                    #[Tags]/*判断每列是否可逆素数*/
                    #[Keywords]for#(flag=1,i=1;flag&&i<=4;i++)#[Keywords]if#(!find1(i))flag=0 ;
                    #[Tags]/*判断对角线是否为可逆素数*/
                    #[Keywords]if#(flag&&find2())
                    #{
                        #printf(#[Fields]"No.%d\n"#,++cc);
                        #fprintf(fp,#[Fields]"No.%d\n"#,cc);
                        #p_array();
                    #}
                    #[Tags]/*输出幻方矩阵*/
                #}
            #}
        #}
    #}
    #fclose(fp);
    #puts(#[Fields]"\n Press any key to quit..."#);
    #getch();
#}
#[Tags]/*判断是否可逆素数*/
#[Keywords]int #num(#[Keywords]int #number)
{
    #[Keywords]int #j ;
    #[Keywords]if#(!ok(number))#[Keywords]return #0 ;
    #[Tags]/*将素数变为反序数*/
    #[Keywords]for#(j=0;number>0;number/=10)j=j*10+number%10 ;
    #[Keywords]if#(!ok(j))#[Keywords]return #0 ;
    #[Tags]/*判断反序数是否为素数*/
    #[Keywords]return #1 ;
#}
#[Tags]/*判断是否为素数*/
#[Keywords]int #ok(#[Keywords]int #number)
{
    #[Keywords]int #i,j ;
    #[Keywords]if#(number%2==0)#[Keywords]return #0 ;
    #j=sqrt((double)number)+1 ;
    #[Keywords]for#(i=3;i<=j;i+=2)
    #[Keywords]if#(number%i==0)#[Keywords]return #0 ;
    #[Keywords]return #1 ;
#}
#[Tags]/*将第i个整数分解为数字并存入数组*/
#[Keywords]void #process(#[Keywords]int #i)
{
    #[Keywords]int #j,num ;
    #num=number[i][0];
    #[Keywords]for#(j=4;j>=1;j--,num/=10)
    #number[i][j]=num%10 ;
#}
#[Tags]/*将array[i][0]指向的素数的各位数字复制到array[i]中*/
#[Keywords]void #copy_num(#[Keywords]int #i)
{
    #[Keywords]int #j ;
    #[Keywords]for#(j=1;j<=4;j++)
    #array[i][j]=number[array[i][0]][j];
#}
#[Tags]/*判断array中每列的前n位是否与可逆素数允许的前n位矛盾*/
#[Keywords]int #comp_num(#[Keywords]int #n)
{
    #[Keywords]static #[Keywords]int #ii ;
    #[Tags]/*用内部静态变量保存前一次查找到的元素下标*/
    #[Keywords]static #[Keywords]int #jj ;
    #[Tags]/*ii:前一次查找前二位的下标，jj:前一次查找前三位的下标*/
    #[Keywords]int #i,num,k,*p ;
    #[Tags]/*p:指向对应的要使用的前一次下标ii或jj*/
    #int*pcount ;
    #[Tags]/*pcount:指向要使用的临时数组数量的计数器*/
    #switch(n)
    #{
        #[Tags]/*根据n的值选择对应的一组控制变量*/
        #[Keywords]case #2 :
        #pcount=&lcount[0];
        #p=&ii ;
        #[Keywords]break# ;
        #[Keywords]case #3 :
        #pcount=&lcount[1];
        #p=&jj ;
        #[Keywords]break# ;
        #default :
        #[Keywords]return #0 ;
    #}
    #[Tags]/*对四列分别进行处理*/
    #[Keywords]for#(i=1;i<=4;i++)
    #{
        #[Tags]/*计算前n位数字代表的数值*/
        #[Keywords]for#(num=0,k=0;k<n;k++)num=num*10+array[k][i];
        #[Tags]/*与前一次最后查找到的元素进行比较*/
        #[Keywords]if#(num<=larray[n-2][*p])#[Keywords]for#(;*p>=0&&num<larray[n-2][*p];(*p)--);
        #[Tags]/*若前次查找到的元素大，则向前找*/
        #[Keywords]else #
        #[Keywords]for#(;p<pcount&&num>larray[n-2][*p];(*p)++);
        #[Tags]/*否则向后找*/
        #[Keywords]if#(*p<0||*p>=*pcount)
        #{
            #[Tags]*p=0 ;
            #[Keywords]return #0 ;
        #}
        #[Keywords]if#(num!=larray[n-2][*p])
        #[Keywords]return #0 ;
        #[Tags]/*前n位不是可逆素数允许的值则返回0*/
    #}
    #[Keywords]return #1 ;
#}
#[Tags]/*判断列方向是否是可逆素数*/
#[Keywords]int #find1(#[Keywords]int #i)
{
    #[Keywords]int #num,j ;
    #[Keywords]for#(num=0,j=0;j<4;j++)
    #num=num*10+array[j][i];
    #[Keywords]return #find0(num);
#}
#[Tags]/*判断对角线方向是否是可逆素数*/
#[Keywords]int #find2(void)
{
    #[Keywords]int #num1,num2,i,j ;
    #[Keywords]for#(num1=0,j=0;j<4;j++)
    #num1=num1*10+array[j][j+1];
    #[Keywords]for#(num2=0,j=0,i=4;j<4;j++,i--)
    #num2=num2*10+array[j][i];
    #[Keywords]if#(find0(num1))return(find0(num2));
    #[Keywords]else #[Keywords]return #0 ;
#}
#[Tags]/*查找是否为满足要求的可逆素数*/
#[Keywords]int #find0(#[Keywords]int #num)
{
    #[Keywords]static #[Keywords]int #j ;
    #[Keywords]if#(num<=number[j][0])#[Keywords]for#(;j>=0&&num<number[j][0];j--);
    #[Keywords]else #[Keywords]for#(;j<count&&num>number[j][0];j++);
    #[Keywords]if#(j<0||j>=count)
    #{
        #j=0 ;
        #[Keywords]return #0 ;
    #}
    #[Keywords]if#(num==number[j][0])#[Keywords]return #1 ;
    #[Keywords]else #[Keywords]return #0 ;
#}
#[Tags]/*输出矩阵*/
#[Keywords]void #p_array(void)
{
    #[Keywords]int #i,j ;
    #[Keywords]for#(i=0;i<4;i++)
    #{
        #[Keywords]for#(j=1;j<=4;j++)
        #{
            #printf(#[Fields]"%d "#,array[i][j]);
            #fprintf(fp,#[Fields]"%d "#,array[i][j]);
        #}
        #printf(#[Fields]"\n"#);
        #fprintf(fp,#[Fields]"\n"#);
    #}
#}
[/code]