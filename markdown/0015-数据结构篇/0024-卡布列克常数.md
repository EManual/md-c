代码如下：
[code=java]
#include<stdio.h>
#[Keywords]void #vr6174(#[Keywords]int#);
#[Keywords]void #parse_sort(#[Keywords]int #num,#[Keywords]int #*each);
#[Keywords]void #max_min(#[Keywords]int #*each,#[Keywords]int #*max,#[Keywords]int #*min);
#[Keywords]void #parse_sort(#[Keywords]int #num,#[Keywords]int #*each);
#[Keywords]int #count=0;
#[Keywords]void #main()
{

    #[Keywords]int #n=1;
    #clrscr();
    #puts(#[Fields]"**************************************************************"#);
    #puts(#[Fields]"*         This program is to verify Comgrich Content.        *"#);
    #puts(#[Fields]"* That is any 4-digit number whose digitals are not the same *"#);
    #puts(#[Fields]"* has the rule: (1) range the 4 digits to get the maximum    *"#);
    #puts(#[Fields]"* 4-digit number, (2) range the 4 digits to get the minimum  *"#);
    #puts(#[Fields]"* 4-digit number, (3) get the difference of these two numbers*"#);
    #puts(#[Fields]"* that is a #[Keywords]new #4-digit number. Continute to calculate with  *"#);
    #puts(#[Fields]"* (1)-(3),the result in the end is 6174,the Comgrich Content.*"#);
    #puts(#[Fields]"**************************************************************"#);
   #[Keywords] while#(n!=0)
    #{
	    #printf(#[Fields]" >> Please input a 4-digit number to verify(0 to quit): "#);
	    #scanf(#[Fields]"%d"#,&n);      #[Tags]/*输入任一整数*/
	    #[Keywords]if#(n==0)
		#[Keywords]break#;
	    #printf(#[Fields]" >> ------ Results of verification: ------------\n"#);
	    #count=0;
	    #vr6174(n);           #[Tags]/*调用函数进行验证*/
	    #printf(#[Fields]" >> ---------------------------------------------\n"#);
    #}
    #puts(#[Fields]"\n Press any key to quit..."#);
    #getch();
#}
#[Keywords]void #vr6174(#[Keywords]int #num)
{
    #[Keywords]int #each[4],max,min;
    #[Keywords]if#(num!=6174&&num)    #[Tags]/*若不等于74且不等于0则进行卡布列克运算*/
    #{
        #parse_sort(num,each);         #[Tags]/*将整数分解，数字存入each数组中*/
        #max_min(each,&max,&min);      #[Tags]/*求数字组成的最大值和最小值*/
        #num=max-min;          #[Tags]/*求最大值和最小值的差*/
        #printf(#[Fields]" >> Step No.%d:  %d-%d=%d\n"#,++count,max,min,num); /*输出该步计算过程*/
        #vr6174(num);         #[Tags]/*递归调用自身继续进行卡布列克运算*/
    #}
#}
#[Keywords]void #parse_sort(#[Keywords]int #num,#[Keywords]int #*each)
{
    #[Keywords]int #i,*j,*k,temp;
    #[Keywords]for#(i=0;i<=4;i++)         #[Tags]/*将NUM分解为数字*/
    #{
        #j=each+3-i;
        #[Tags]*j=num%10;
        #num/=10;
    #}
    #[Keywords]for#(i=0;i<3;i++)     #[Tags]/*对各保数字从小到大进行排序*/
        #[Keywords]for#(j=each,k=each+1;j<each+3-i;j++,k++)
            #[Keywords]if#(*j>*k) { temp=*j;*j=*k;*k=temp;#}
    #[Keywords]return#;#
#}
#[Keywords]void #max_min(#[Keywords]int #*each,#[Keywords]int #*max,#[Keywords]int #*min)    
#[Tags]/*将分解的数字还原为最大整数和最小整数*/
{
    #[Keywords]int #*i;
    #[Tags]*min=0;
    #[Keywords]for#(i=each;i<each+4;i++)     #[Tags]/*还原为最小的整数*/
        #[Tags]*min=#[Tags]*min#[Tags]*10+#[Tags]*i;
    #[Tags]*max=0;
    #[Keywords]for#(i=each+3;i>=each;i--)    #[Tags]/*还原为最大的整数*/
        #[Tags]*max=#[Tags]*max#[Tags]*10+#[Tags]*i;
    #[Keywords]return#;#
#}
[/code]