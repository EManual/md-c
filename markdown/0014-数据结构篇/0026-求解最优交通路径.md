代码如下：
[code=java]
#[Tags]/*交通图最短路径程序*/
#include #[Fields]"string.h"# 
#include #[Fields]"stdio.h"# 
typedef struct ArcCell 
{
    #[Keywords]int #adj ;
    #[Tags]/*相邻接的城市序号*/
#}
ArcCell ;
#[Tags]/*定义边的类型*/
typedef struct VertexType 
{
    #[Keywords]int #number ;
    #[Tags]/*城市序号*/
    #char*city ;
    #[Tags]/*城市名称*/
#}
VertexType ;
#[Tags]/*定义顶点的类型*/
typedef struct 
{
    #VertexType vex[25];
    #[Tags]/*图中的顶点，即为城市*/
    #ArcCell arcs[25][25];
    #[Tags]/*图中的边，即为城市间的距离*/
    #[Keywords]int #vexnum,arcnum ;
    #[Tags]/*顶点数，边数*/
#}
MGraph ;
#[Tags]/*定义图的类型*/
MGraph G ;
#[Tags]/*把图定义为全局变量*/
#[Keywords]int #P[25][25];
#[Keywords]long #[Keywords]int #D[25];
#[Tags]/*造图函数*/
#[Keywords]void #CreateUDN(v,a)#[Keywords]int #v,a ;
{
    #[Keywords]int #i,j ;
    #G.vexnum=v ;
    #G.arcnum=a ;
    #[Keywords]for#(i=0;i<G.vexnum;++i)G.vex[i].number=i ;
    #[Tags]/*下边是城市名*/
    #G.vex[0].city=#[Fields]"乌鲁木齐"# ;
    #G.vex[1].city=#[Fields]"西宁"# ;
    #G.vex[2].city=#[Fields]"兰州"# ;
    #G.vex[3].city=#[Fields]"呼和浩特"# ;
    #G.vex[4].city=#[Fields]"北京"# ;
    #G.vex[5].city=#[Fields]"天津"# ;
    #G.vex[6].city=#[Fields]"沈阳"# ;
    #G.vex[7].city=#[Fields]"长春"# ;
    #G.vex[8].city=#[Fields]"哈尔滨"# ;
    #G.vex[9].city=#[Fields]"大连"# ;
    #G.vex[10].city=#[Fields]"西安"# ;
    #G.vex[11].city=#[Fields]"郑州"# ;
    #G.vex[12].city=#[Fields]"徐州"# ;
    #G.vex[13].city=#[Fields]"成都"# ;
    #G.vex[14].city=#[Fields]"武汉"# ;
    #G.vex[15].city=#[Fields]"上海"# ;
    #G.vex[16].city=#[Fields]"昆明"# ;
    #G.vex[17].city=#[Fields]"贵州"# ;
    #G.vex[18].city=#[Fields]"株洲"# ;
    #G.vex[19].city=#[Fields]"南昌"# ;
    #G.vex[20].city=#[Fields]"福州"# ;
    #G.vex[21].city=#[Fields]"柳州"# ;
    #G.vex[22].city=#[Fields]"南宁"# ;
    #G.vex[23].city=#[Fields]"广州"# ;
    #G.vex[24].city=#[Fields]"深圳"# ;
    #[Tags]/*这里把所有的边假定为20000，含义是城市间不可到达*/
    #[Keywords]for#(i=0;i<G.vexnum;++i)
    #[Keywords]for#(j=0;j<G.vexnum;++j)
    #G.arcs[i][j].adj=20000 ;
    #[Tags]/*下边是可直接到达的城市间的距离，由于两个城市间距离是互相的，
    #[Tags]所以要对图中对称的边同时赋值。*/
    #G.arcs[0][2].adj=G.arcs[2][0].adj=1892 ;
    #G.arcs[1][2].adj=G.arcs[2][1].adj=216 ;
    #G.arcs[2][3].adj=G.arcs[3][2].adj=1145 ;
    #G.arcs[2][10].adj=G.arcs[10][2].adj=676 ;
    #G.arcs[3][4].adj=G.arcs[4][3].adj=668 ;
    #G.arcs[4][5].adj=G.arcs[5][4].adj=137 ;
    #G.arcs[5][6].adj=G.arcs[6][5].adj=704 ;
    #G.arcs[6][7].adj=G.arcs[7][6].adj=305 ;
    #G.arcs[7][8].adj=G.arcs[8][7].adj=242 ;
    #G.arcs[6][9].adj=G.arcs[9][6].adj=397 ;
    #G.arcs[4][11].adj=G.arcs[11][4].adj=695 ;
    #G.arcs[5][12].adj=G.arcs[12][5].adj=674 ;
    #G.arcs[10][13].adj=G.arcs[13][10].adj=842 ;
    #G.arcs[11][14].adj=G.arcs[14][11].adj=534 ;
    #G.arcs[12][15].adj=G.arcs[15][12].adj=651 ;
    #G.arcs[13][16].adj=G.arcs[16][13].adj=1100 ;
    #G.arcs[13][17].adj=G.arcs[17][13].adj=967 ;
    #G.arcs[14][18].adj=G.arcs[18][14].adj=409 ;
    #G.arcs[17][18].adj=G.arcs[18][17].adj=902 ;
    #G.arcs[15][19].adj=G.arcs[19][15].adj=825 ;
    #G.arcs[18][19].adj=G.arcs[19][18].adj=367 ;
    #G.arcs[19][20].adj=G.arcs[20][19].adj=622 ;
    #G.arcs[17][21].adj=G.arcs[21][17].adj=607 ;
    #G.arcs[18][21].adj=G.arcs[21][18].adj=672 ;
    #G.arcs[21][22].adj=G.arcs[22][21].adj=255 ;
    #G.arcs[18][23].adj=G.arcs[23][18].adj=675 ;
    #G.arcs[23][24].adj=G.arcs[24][23].adj=140 ;
    #G.arcs[16][17].adj=G.arcs[17][16].adj=639 ;
    #G.arcs[10][11].adj=G.arcs[11][10].adj=511 ;
    #G.arcs[11][12].adj=G.arcs[12][11].adj=349 ;
#}
#[Tags]/*说明函数*/
#[Keywords]void #narrate()
{
    #[Keywords]int #i,k=0 ;
    #printf(#[Fields]"\n*****************欢迎使用最优交通路径程序!***************\n"#);
    #printf(#[Fields]"\n城市列表如下:\n\n"#);
    #[Keywords]for#(i=0;i<25;i++)
    #{
        #printf(#[Fields]"(%2d)%-10s"#,i,G.vex[i].city);
        #[Tags]/*输出城市列表*/
        #k=k+1 ;
        #[Keywords]if#(k%4==0)printf(#[Fields]"\n"#);
    #}
#}
#[Tags]/*最短路径函数*/
#[Keywords]void #ShortestPath(num)#[Keywords]int #num ;
{
    #[Keywords]int #v,w,i,t ;
    #[Keywords]int #final[25];
    #[Keywords]int #min ;
    #[Keywords]for#(v=0;v<25;++v)
    #{
        #final[v]=0 ;
        #D[v]=G.arcs[num][v].adj ;
        #[Keywords]for#(w=0;w<25;++w)P[v][w]=0 ;
        #[Keywords]if#(D[v]<20000)
        #{
            #P[v][num]=1 ;
            #P[v][v]=1 ;
        #}
    #}
    #D[num]=0 ;
    #final[num]=1 ;
    #[Keywords]for#(i=0;i<25;++i)
    #{
        #min=20000 ;
        #[Keywords]for#(w=0;w<25;++w)
        #[Keywords]if#(!final[w])
        #[Keywords]if#(D[w]<min)
        #{
            #v=w ;
            #min=D[w];
        #}
        #final[v]=1 ;
        #[Keywords]for#(w=0;w<25;++w)
        #[Keywords]if#(!final[w]&&((min+G.arcs[v][w].adj)<D[w]))
        #{
            #D[w]=min+G.arcs[v][w].adj ;
            #[Keywords]for#(t=0;t<25;t++)P[w][t]=P[v][t];
            #P[w][w]=1 ;
        #}
    #}
#}
#[Tags]/*输出函数*/
#[Keywords]void #output(city1,city2)#[Keywords]int #city1 ;
#[Keywords]int #city2 ;
{
    #[Keywords]int #a,b,c,d,q=0 ;
    #a=city2 ;
    #[Keywords]if#(a!=city1)
    #{
        #printf(#[Fields]"\n从%s到%s的最短路径是"#,G.vex[city1].city,G.vex[city2].city);
        #printf(#[Fields]"(最短距离为 %dkm.)\n\t"#,D[a]);
        #printf(#[Fields]"%s"#,G.vex[city1].city);
        #d=city1 ;
        #[Keywords]for#(c=0;c<25;++c)
        #{
            #gate :
            #;
            #[Tags]/*标号，可以作为goto语句跳转的位置*/
            #P[a][city1]=0 ;
            #[Keywords]for#(b=0;b<25;b++)
            #{
                #[Keywords]if#(G.arcs[d][b].adj<20000&&P[a][b])
                #{
                    #printf(#[Fields]"-->%s"#,G.vex[b].city);
                    #q=q+1 ;
                    #P[a][b]=0 ;
                    #d=b ;
                    #[Keywords]if#(q%8==0)printf(#[Fields]"\n"#);
                    #goto gate ;
                #}
            #}
        #}
    #}
    
#}
#[Tags]/*主函数*/
#[Keywords]void #main()
{
    #[Keywords]int #v0,v1 ;
    #CreateUDN(25,30);
    
    #narrate();
    #printf(#[Fields]"\n\n请选择起点城市（0～24）：\n"#);
    #scanf(#[Fields]"%d"#,&v0);
    #printf(#[Fields]"请选择终点城市（0～24）：\n"#);
    #scanf(#[Fields]"%d"#,&v1);
    #ShortestPath(v0);
    #[Tags]/*计算两个城市之间的最短路径*/
    #output(v0,v1);
    #[Tags]/*输出结果*/
    #printf(#[Fields]"\n"#);
    #printf(#[Fields]"\n 请按任意键退出...\n"#);
    #getch();
#}
[/code]