代码如下：
[code=java]
#include #[Fields]"stdafx.h
#include #[Fields]"stdio.h
#include #[Fields]"iostream.h
#include #[Fields]"stdlib.h
#include #[Fields]"malloc.h
#include #[Fields]"string.h
#define StackSize 100 
#[Comments]//假定预分配的栈空间最多为100个元素
#define MaxLength  100
#[Comments]// 最大的字符串长度
typedef #[Keywords]int #DataType ;
#[Comments]//假定栈元素的数据类型为整数
typedef struct 
{
    #DataType data[StackSize];
    #[Keywords]int #top ;
#}
SeqStack ;
#[Comments]// 置栈空
#[Keywords]void #Initial(SeqStack*S)
{
    #[Comments]//将顺序栈置空
    #S->top=-1 ;
#}
#[Comments]//判栈空
#[Keywords]int #IsEmpty(SeqStack*S)
{
    #[Keywords]return #S->top==-1 ;
#}
#[Comments]//判栈满
#[Keywords]int #IsFull(SeqStack*S)
{
    #[Keywords]return #S->top==StackSize-1 ;
#}
#[Comments]//进栈
#[Keywords]void #Push(SeqStack*S,DataType x)
{
    #[Keywords]if#(IsFull(S))
    #{
        #printf(#[Fields]"栈上溢"#);
        #[Comments]//上溢,退出运行
        #exit(1);
    #}
    #S->data[++S->top]=x ;
    #[Comments]//栈顶指针加1后将x入栈
#}
#[Comments]//出栈
DataType Pop(SeqStack*S)
{
    #[Keywords]if#(IsEmpty(S))
    #{
        #printf(#[Fields]"栈为空"#);
        #[Comments]//下溢,退出运行
        #return-1 ;
    #}
    #[Keywords]return #S->data[S->top--];
    #[Comments]//栈顶元素返回后将栈顶指针减1
#}
#[Comments]// 取栈顶元素
DataType Top(SeqStack*S)
{
    #[Keywords]if#(IsEmpty(S))
    #{
        #printf(#[Fields]"栈为空"#);
        #[Comments]//下溢,退出运行
        #exit(1);
    #}
    #[Keywords]return #S->data[S->top];
#}
#[Keywords]int #Hold(#[Keywords]int #c,int*minH,int*minS,SeqStack H[],#[Keywords]int #k,#[Keywords]int #n)
{
    #[Comments]// 在一个缓冲铁轨中放入车厢c
    #[Comments]// 如果没有可用的缓冲铁轨，则返回0
    #[Comments]// 如果空间不足，则引发异常N o M e m
    #[Comments]// 否则返回1
    #[Comments]// 为车厢c寻找最优的缓冲铁轨
    #[Comments]// 初始化
    #[Keywords]int #BestTrack=0,i ;
    #[Comments]// 目前最优的铁轨
    #[Keywords]int #BestTop=n+1 ;
    #[Comments]// 最优铁轨上的头辆车厢
    #[Keywords]int #x ;
    #[Comments]// 车厢索引
    #[Comments]//扫描缓冲铁轨
    #[Keywords]for#(i=1;i<=k;i++)
    #[Keywords]if#(IsEmpty(&H[i]))
    #{
        #[Comments]// 铁轨i 不空
        #x=Top(&H[i]);
        #[Keywords]if#(c<x&&x<BestTop)
        #{
            #[Comments]//铁轨i 顶部的车厢编号最小
            #BestTop=x ;
            #BestTrack=i ;
        #}
    #}
    #[Comments]// 铁轨i 为空
    #[Keywords]else #[Keywords]if#(!BestTrack)
    #BestTrack=i ;
    #[Keywords]if#(!BestTrack)
    #[Keywords]return #0 ;
    #[Comments]//没有可用的铁轨
    #[Comments]//把车厢c 送入缓冲铁轨
    #Push(&H[BestTrack],c);
    #printf(#[Fields]"Move car %d  from input to holding track %d\n"#,c,BestTrack);
    #[Comments]//必要时修改minH 和minS
    #[Keywords]if#(c<*minH)
    #{
        #[Tags]*minH=c ;
        #[Tags]*minS=BestTrack ;
    #}
    #[Keywords]return #1 ;
#}
#[Keywords]void #Output(int*minH,int*minS,SeqStack H[],#[Keywords]int #k,#[Keywords]int #n)
{
    #[Comments]//把车厢从缓冲铁轨送至出轨处，同时修改m i n S和m i n H
    #[Keywords]int #c,i ;
    #[Comments]// 车厢索引
    #[Comments]// 从堆栈m i n S中删除编号最小的车厢minH
    #c=Pop(&H[*minS]);
    #printf(#[Fields]"Move car %d from holding track %d to output\n"#,*minH,*minS);
    #[Comments]// 通过检查所有的栈顶，搜索新的m i n H和m i n S
    #[Tags]*minH=n+2 ;
    #[Keywords]for#(i=1;i<=k;i++)
    #[Keywords]if#(!IsEmpty(&H[i])&&(c=Top(&H[i]))<*minH)
    #{
        #[Tags]*minH=c ;
        #[Tags]*minS=i ;
    #}
#}
#[Keywords]int #Railroad(#[Keywords]int #p[],#[Keywords]int #n,#[Keywords]int #k)
{
    #[Comments]// k个缓冲铁轨，车厢初始排序为p [1:n]
    #[Comments]// 如果重排成功，返回1，否则返回0
    #[Comments]// 如果内存不足，则引发异常NoMem 。
    #[Comments]//创建与缓冲铁轨对应的堆栈
    #SeqStack*H ;
    #[Keywords]int #NowOut=1 ;
    #[Comments]//下一次要输出的车厢
    #[Keywords]int #minH=n+1 ;
    #[Comments]//缓冲铁轨中编号最小的车厢
    #[Keywords]int #minS,i ;
    #[Comments]//minH号车厢对应的缓冲铁轨
    #H=(SeqStack*)calloc((k+1),sizeof(SeqStack)*(k+1));
    #[Comments]//车厢重排
    #[Keywords]for#(i=1;i<=n;i++)
    #[Keywords]if#(p[i]==NowOut)
    #{
        #[Comments]// 直接输出t
        #printf(#[Fields]"移动车厢%d从出口到入口"#,p[i]);
        #NowOut++;
        #[Comments]//从缓冲铁轨中输出
       #[Keywords] while#(minH==NowOut)
        #{
            #Output(&minH,&minS,H,k,n);
            #NowOut++;
        #}
    #}
    #[Keywords]else #
    #{
        #[Comments]// 将p[i] 送入某个缓冲铁轨
        #[Keywords]if#(!Hold(p[i],&minH,&minS,H,k,n))
        #[Keywords]return #0 ;
    #}
    #[Keywords]return #1 ;
#}
#[Keywords]void #main(void)
{
    #[Keywords]int #p[8]=
    #{
        #2,4,1,6,5,3,8,7
    #}
    #;
    #Railroad(p,8,4);
#}
[/code]