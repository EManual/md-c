代码如下：
[code=java]
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
struct Family*get_person(void);
#[Tags]/* Prototype #[Keywords]for #input function */
#[Keywords]char #related(struct Family*pmember1,struct Family*pmember2);
#[Keywords]char #set_ancestry(struct Family*pmember1,struct Family*pmember2);
struct Date 
{
    #[Keywords]int #day ;
    #[Keywords]int #month ;
    #[Keywords]int #year ;
#}
;
#[Tags]/* Family structure declaration   */
struct Family 
{
    #struct Date dob ;
    #[Keywords]char #name[20];
    #[Keywords]char #father[20];
    #[Keywords]char #mother[20];
    #struct Family*next ;
    #[Tags]/* Pointer to next structure      */
    #struct Family*previous ;
    #[Tags]/* Pointer to previous structure  */
    #struct Family*p_to_pa ;
    #[Tags]/* Pointer to father structure   */
    #struct Family*p_to_ma ;
    #[Tags]/* Pointer to mother structure   */
#}
;
#[Keywords]void #main()
{
    #struct Family*first=NULL ;
    #[Tags]/* Pointer to first person        */
    #struct Family*current=NULL ;
    #[Tags]/* Pointer to current person      */
    #struct Family*last=NULL ;
    #[Tags]/* Pointer to previous person     */
   
    #[Keywords]char #more=#[Fields]'\0'# ;
    #[Tags]/* Test value #[Keywords]for #ending input    */
    #[Keywords]for#(;;)
    #{
        #printf(#[Fields]"\nDo you want to enter details of a%s person (Y or N)? "#,
        #first!=NULL?#[Fields]"nother "#:#[Fields]""#);
        #scanf(#[Fields]" %c"#,&more);
        #[Keywords]if#(tolower(more)==#[Fields]'n'#)
        #[Keywords]break# ;
        #current=get_person();
        #[Keywords]if#(first==NULL)
        #{
            #first=current ;
            #[Tags]/* Set pointer to first Family    */
            #last=current ;
            #[Tags]/* Remember #[Keywords]for #next iteration    */
        #}
        #[Keywords]else #
        #{
            #last->next=current ;
            #[Tags]/* Set next address #[Keywords]for #previous Family */
            #current->previous=last ;
            #[Tags]/* Set previous address #[Keywords]for #current */
            #last=current ;
            #[Tags]/* Remember #[Keywords]for #next iteration */
        #}
    #}
    #current=first ;
    #/* Check #[Keywords]for #relation #[Keywords]for #each person in    */
   #[Keywords] while#(current->next!=NULL)
    #{
        #[Tags]/* the list up to second to last            */
        #[Keywords]int #parents=0 ;
        #[Tags]/* Declare parent count local to #[Keywords]this# block */
        #last=current->next ;
        #[Tags]/* Get the pointer to the next              */
        #[Tags]/* This loop tests current person           */
       #[Keywords] while#(last!=NULL)
        #{
            #[Tags]/* against all the remainder in the list    */
            #[Tags]/* Found a parent ?          */
            #[Tags]/* Yes, update count and check it        */
            #[Keywords]if#(related(current,last))#[Keywords]if#(++parents==2)#[Keywords]break# ;
            #[Tags]/* Exit inner loop #[Keywords]if #both parents found */
            #last=last->next ;
            #[Tags]/* Get the address of the next           */
        #}
        #current=current->next ;
        #[Tags]/* Next in the list to check             */
    #}
    #[Tags]/* Now tell them what we know */
    #[Tags]/* Output Family data in correct order */
    #current=first ;
    #[Tags]/* Output Family data in correct order  */
   #[Keywords] while#(current!=NULL)
    #{
        #printf(#[Fields]"\n%s was born %d/%d/%d, and has %s and %s as parents."#,
        #current->name,current->dob.day,current->dob.month,
        #current->dob.year,current->father,current->mother);
        #[Keywords]if#(current->p_to_pa!=NULL)
        #printf(#[Fields]"\n\t%s#[Fields]'s birth date is %d/%d/%d  "#,
        #current->father,current->p_to_pa->dob.day,
        #current->p_to_pa->dob.month,
        #current->p_to_pa->dob.year);
        #[Keywords]if#(current->p_to_ma!=NULL)
        #printf(#[Fields]"and %s#[Fields]'s birth date is %d/%d/%d.\n  "#,
        #current->mother,current->p_to_ma->dob.day,
        #current->p_to_ma->dob.month,
        #current->p_to_ma->dob.year);
        #current=current->next ;
        #[Tags]/* current points to next in list       */
    #}
    #[Tags]/* Now free the memory */
    #current=first ;
   #[Keywords] while#(current->next!=NULL)
    #{
        #last=current ;
        #[Tags]/* Save pointer to enable memory to be freed */
        #current=current->next ;
        #[Tags]/* current points to next in list       */
        #free(last);
        #[Tags]/* Free memory #[Keywords]for #last                      */
    #}
#}
#[Tags]/*   Function to input data on Family members   */
struct Family*get_person(void)
{
    #struct Family*temp ;
    #[Tags]/* Define temporary structure pointer */
    #[Tags]/* Allocate memory #[Keywords]for #a structure */
    #temp=(struct Family*)malloc(sizeof(struct Family));
    #printf(#[Fields]"\nEnter the name of the person: "#);
    #scanf(#[Fields]"%s"#,temp->name);
    #[Tags]/* Read the Family#[Fields]'s name */
    #printf(#[Fields]"\nEnter %s#[Fields]'s date of birth (day month year); "#,temp->name);
    #scanf(#[Fields]"%d %d %d"#,&temp->dob.day,&temp->dob.month,&temp->dob.year);
    #printf(#[Fields]"\nWho is %s#[Fields]'s father? "#,temp->name);
    #scanf(#[Fields]"%s"#,temp->father);
    #[Tags]/* Get the father#[Fields]'s name */
    #printf(#[Fields]"\nWho is %s#[Fields]'s mother? "#,temp->name);
    #scanf(#[Fields]"%s"#,temp->mother);
    #[Tags]/* Get the mother#[Fields]'s name */
    #temp->next=temp->previous=NULL ;
    #[Tags]/* Set pointers to NULL */
    #temp->p_to_pa=temp->p_to_ma=NULL ;
    #[Tags]/* Set pointers to NULL  */
    #[Keywords]return #temp ;
    #[Tags]/* Return address of Family structure */
#}
#[Keywords]char #set_ancestry(struct Family*pmember1,struct Family*pmember2)
{
    #[Keywords]if#(strcmp(pmember1->father,pmember2->name)==0)
    #{
        #pmember1->p_to_pa=pmember2 ;
        #[Keywords]return #1 ;
    #}
    #[Keywords]if#(strcmp(pmember1->mother,pmember2->name)==0)
    #{
        #pmember1->p_to_ma=pmember2 ;
        #[Keywords]return #1 ;
    #}
    #[Keywords]else #
    #[Keywords]return #0 ;
#}
#[Tags]/* Fill in pointers #[Keywords]for #mother or father relationships */
#[Keywords]char #related(struct Family*pmember1,struct Family*pmember2)
{
    #[Keywords]return #set_ancestry(pmember1,pmember2)||
    #set_ancestry(pmember2,pmember1);
#}
[/code]