代码如下：
[code=java]
#include<stdio.h>
#include<stdlib.h>
#define NULL 0 #[Tags]/*宏定义*/
typedef struct node #[Tags]/*定义结点类型的数据结构*/
{
	#[Keywords]char #c; #[Tags]/*数据域，类型为字符型*/
	#struct node *next; #[Tags]/*指针域，类型为本结构体类型*/
#}Node,*L; #[Tags]/*类型重定义，即Node和*L和struct node等价*/
main()
{
	#L l,p,q,r; #[Tags]/*用指针类型定义三个结点类型的指针*/
	#[Keywords]char #ch;
	#l=(L)malloc(sizeof(Node)); #[Tags]/*分配内存空间*/
	#l->c=#[Fields]'\0'#; #[Tags]/*为头结点的数据域赋值，值为空*/
	#l->next=NULL; #[Tags]/*指明下一个结点目前不存在*/
	#q=l; #[Tags]/*q为游动指针，链表结点的连结要用*/
	#printf(#[Fields]"Input a character:\n"#);
	#scanf(#[Fields]"%c"#,&ch);
	#getchar();
	#[Keywords]while#(ch!=#[Fields]'0'#) #[Tags]/*输入0表示输入结束*/
	#{
		#p=(L)malloc(sizeof(Node)); #[Tags]/*为新输入的数据分配内存空间*/
		#p->c=ch;
		#p->next=NULL; #[Tags]/*新输入的结点在链表的最后，即它的后面没有其它元素*/
		#q->next=p; #[Tags]/*q用于将上一个元素链接至当前新元素*/
		#q=p; #[Tags]/*q自己移到当前最后一个元素，以备继续链接所用*/
		#scanf(#[Fields]"%c"#,&ch);
		#getchar();
	#}	
	#/*以上完成了单链表的创建*/
	#q=l->next;
	#p=q->next;
	#r=p->next;
	#q->next=NULL;
	#[Keywords]while#(r!=NULL)
	#{
		#p->next=q;
		#q=p;
		#p=r;
		#[Keywords]if#(r->next!=NULL) #[Tags]/*r后面还有结点，则逆置继续*/
			#r=r->next;
		#else
			#[Keywords]break#;
	#}
	#r->next=q;
	#l->next=r; #[Comments]//头结点指向最后一个结点
	
	#q=l; #[Tags]/*输入整个链表前，先将q移到链表头，l一般不动*/
	#[Keywords]while#(q->next!=NULL) #[Tags]/*若q所指向的元素后面还有其它元素，则将该元素的数据输出*/
	#{
		#printf(#[Fields]"%c-->"#,q->next->c); #[Tags]/*q->next->c表示q所指向的下一个元素的数据*/
		#q=q->next; #[Tags]/*完成该元素的输出后，q移至下一个元素重复输出操作*/
	#}
	#printf(#[Fields]"\n"#);
#}
[/code]