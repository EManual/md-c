代码如下：
[code=java]
#[Comments]//////////////////////////////////////////////////////////////////////////
#[Tags]/*                       骑士巡游问题                                   */
#[Comments]/////////////////////////////////////////////////////////////////////////

#include<stdio.h>
#[Keywords]int #f[11][11];
#[Tags]/*定义一个矩阵来模拟棋盘*/
#[Keywords]int #adjm[121][121];
#[Tags]/*标志矩阵，即对于上述棋盘，依次进行编号
#[Tags]		    #1--121(行优先）可以从一个棋盘格i跳到棋盘格j时，adjm[i][j]=1*/
#[Keywords]void #creatadjm(void);
#[Tags]/*创建标志矩阵函数声明*/
#[Keywords]void #mark(int,int,int,#[Keywords]int#);
#[Tags]/*将标志矩阵相应位置置1*/
#[Keywords]void #travel(int,#[Keywords]int#);
#[Tags]/*巡游函数声明*/
#[Keywords]int #n,m ;
#[Tags]/*定义矩阵大小及标志矩阵的大小*/
#[Tags]/******************************主函数***********************************/
#[Keywords]int #main()
{
    #[Keywords]int #i,j,k,l ;
    #printf(#[Fields]"Please input size of the chessboard: "#);
    #/*输入矩阵的大小值*/
    #scanf(#[Fields]"%d"#,&n);
    #m=n*n ;
    #creatadjm();
    #/*创建标志矩阵*/
    #puts(#[Fields]"The sign matrix is:"#);
    #/*打印输出标志矩阵*/
    #[Keywords]for#(i=1;i<=m;i++)
    #{
        #[Keywords]for#(j=1;j<=m;j++)
        #printf(#[Fields]"%2d"#,adjm[i][j]);
        #printf(#[Fields]"\n"#);
    #}
    
    #printf(#[Fields]"Please input the knight#[Fields]'s position (i,j): "#);
    #/*输入骑士的初始位置*/
    #scanf(#[Fields]"%d %d"#,&i,&j);
    #l=(i-1)*n+j ;
    #/*骑士当前位置对应的标志矩阵的横坐标*/
    #/*对骑士位置的判断*/
   #[Keywords] while#((i>0)||(j>0))
    #{
        #/*棋盘矩阵初始化*/
        #[Keywords]for#(i=1;i<=n;i++)#[Keywords]for#(j=1;j<=n;j++)
        #f[i][j]=0 ;
        #k=0 ;
        #/*所跳步数计数*/
        #travel(l,k);
        #/*从i,j出发开始巡游*/
        #puts(#[Fields]"The travel steps are:"#);
        #/*巡游完成后输出巡游过程*/
        #[Keywords]for#(i=1;i<=n;i++)
        #{
            #[Keywords]for#(j=1;j<=n;j++)
            #printf(#[Fields]"%4d"#,f[i][j]);
            #printf(#[Fields]"\n"#);
        #}
        
        #printf(#[Fields]"Please input the knight#[Fields]'s position (i,j): "#);
        #/*为再次巡游输入起始位置*/
        #scanf(#[Fields]"%d %d"#,&i,&j);
        #l=(i-1)*n+j ;
    #}
    #puts(#[Fields]"\n Press any key to quit... "#);
    #getch();
    #[Keywords]return #0 ;
#}
#[Tags]/*****************************创建标志矩阵子函数*************************/
#[Keywords]void #creatadjm()
{
    #[Keywords]int #i,j ;
    #/*巡游矩阵初始化*/
    #[Keywords]for#(i=1;i<=n;i++)#[Keywords]for#(j=1;j<=n;j++)
    #f[i][j]=0 ;
    #/*标志矩阵初始化*/
    #[Keywords]for#(i=1;i<=m;i++)#[Keywords]for#(j=1;j<=m;j++)
    #adjm[i][j]=0 ;
    #[Keywords]for#(i=1;i<=n;i++)
    #[Keywords]for#(j=1;j<=n;j++)
    #/*对所有符合条件的标志矩阵种元素置1*/
    #[Keywords]if#(f[i][j]==0)
    #{
        #f[i][j]=1 ;
        #[Keywords]if#((i+2<=n)&&(j+1<=n))mark(i,j,i+2,j+1);
        #[Keywords]if#((i+2<=n)&&(j-1>=1))mark(i,j,i+2,j-1);
        #[Keywords]if#((i-2>=1)&&(j+1<=n))mark(i,j,i-2,j+1);
        #[Keywords]if#((i-2>=1)&&(j-1>=1))mark(i,j,i-2,j-1);
        #[Keywords]if#((j+2<=n)&&(i+1<=n))mark(i,j,i+1,j+2);
        #[Keywords]if#((j+2<=n)&&(i-1>=1))mark(i,j,i-1,j+2);
        #[Keywords]if#((j-2>=1)&&(i+1<=n))mark(i,j,i+1,j-2);
        #[Keywords]if#((j-2>=1)&&(i-1>=1))mark(i,j,i-1,j-2);
    #}
    #[Keywords]return #;
#}
#[Tags]/*********************************巡游子函数*******************************/
#[Keywords]void #travel(#[Keywords]int #p,#[Keywords]int #r)
{
    #[Keywords]int #i,j,q ;
    #[Keywords]for#(i=1;i<=n;i++)
    #[Keywords]for#(j=1;j<=n;j++)
    #[Keywords]if#(f[i][j]>r)f[i][j]=0 ;
    #/*棋盘矩阵的置〉r时，置0*/
    #r=r+1 ;
    #/*跳步计数加1*/
    #i=((p-1)/n)+1 ;
    #/*还原棋盘矩阵的横坐标*/
    #j=((p-1)%n)+1 ;
    #/*还原棋盘矩阵的纵坐标*/
    #f[i][j]=r ;
    #/*将f[i][j]做为第r跳步的目的地*/
    #/*从所有可能的情况出发，开始进行试探式巡游*/
    #[Keywords]for#(q=1;q<=m;q++)
    #{
        #i=((q-1)/n)+1 ;
        #j=((q-1)%n)+1 ;
        #[Keywords]if#((adjm[p][q]==1)&&(f[i][j]==0))
        #travel(q,r);
        #/*递归调用自身*/
    #}
    #[Keywords]return #;
#}
#[Tags]/*************************赋值子函数***************************************/
#[Keywords]void #mark(#[Keywords]int #i1,#[Keywords]int #j1,#[Keywords]int #i2,#[Keywords]int #j2)
{
    #adjm[(i1-1)*n+j1][(i2-1)*n+j2]=1 ;
    #adjm[(i2-1)*n+j2][(i1-1)*n+j1]=1 ;
    #[Keywords]return #;
#}
[/code]