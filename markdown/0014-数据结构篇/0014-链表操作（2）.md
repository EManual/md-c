代码如下：
[code=java]
#include #[Fields]"stdafx.h
#include #[Fields]"stdio.h
#ifndef SQLIST_H
#define SQLIST_H
#include <stdlib.h>
#define List_INIT_SIZE  100   #[Comments]//线性表的存储空间初始大小
#define LIST_INCREMENT  10    #[Comments]//分配增量
#define OVERFLOW   -2
#define OK     1
#define ERROR    -1
#define TRUE    1
#define FALSE    0
typedef #[Keywords]int # ElemType;
typedef struct{
	#ElemType *elem;  #[Comments]//存储空间基址
	#[Keywords]int #  length;  #[Comments]//当前长度
	#[Keywords]int #  size;    #[Comments]//当前存储容量(sizeof(ElemType)为单位)
#}SqList;
#[Keywords]int #InitList(SqList &L)
{
	#[Comments]//构建一个线性表L
	#L.elem = (ElemType*)malloc(List_INIT_SIZE*sizeof(ElemType));
	#[Keywords]if#(!L.elem)
	#{
		#exit(OVERFLOW);
	#}
	#L.length = 0;
	#L.size = List_INIT_SIZE;
	#[Keywords]return #OK;
#}#[Comments]//InitList

#[Keywords]void #DestoryList(SqList &L)
{
	#[Keywords]if#(!L.elem)
	#{
		#delete L.elem;
		#L.elem = NULL;
	#}
	#L.length = 0;
	#L.size = 0;
#}#[Comments]//DestoryList

#[Keywords]void #ClearList(SqList &L)
{
	#L.elem = NULL;
	#L.length = 0;
	#L.size = List_INIT_SIZE;
#}#[Comments]//ClearList

#[Keywords]int #ListEmpty(SqList L)
{
	#[Keywords]if#(L.length > 0)
	#{
		#[Keywords]return #TRUE;
	#}
	#else
	#{
		#[Keywords]return #FALSE;
	#}
#}#[Comments]//ListEmpty

#[Keywords]int #ListLength(SqList L)
{
	#[Keywords]return #L.length;
#}#[Comments]//ListLength

#[Keywords]int #ListInsert(SqList &L, #[Keywords]int #i, ElemType e)
{
	#[Keywords]if#(i<1 || i>ListLength(L)+1) #[Comments]//需满足条件1<i<ListLength(L)+1
	#{
		#[Keywords]return #ERROR;
	#}
	#ElemType * NewBase;  #[Comments]//新的基址
	#[Keywords]if#(L.length > L.size) #[Comments]//空间已满
	#{
		#NewBase = (ElemType*)malloc((L.size+LIST_INCREMENT)*sizeof(ElemType));  #[Comments]//申请新的空间
		#[Keywords]if#(!NewBase)
		#{
			#exit(OVERFLOW);
		#}
		#L.elem = NewBase;
		#L.size +=LIST_INCREMENT;
		#delete NewBase;
		#NewBase = NULL;
	#}
	#ElemType *p;
	#ElemType *temp;
	#p = &(L.elem[i-1]);  #[Comments]//取得i的位置，即插入位置
	#[Keywords]for#(temp = &(L.elem[L.length-1]);temp>p;--temp)  #[Comments]//将插入点后的所有元素向后移动一位
	#{
		#[Tags]*(temp+1) = #[Tags]*temp;
	#}
	#[Tags]*p = e;
	#++L.length;
	#[Keywords]return #OK;
#}#[Comments]//ListInsert

#[Keywords]int #ListDelete(SqList &L, #[Keywords]int #i, ElemType &e)
{
	#[Keywords]if #(i<0 || i>ListLength(L)) {
		#[Keywords]return #ERROR;
	#}
	#ElemType *p;
	#p = &(L.elem[i-1]);
	#e = *p;
	#ElemType *pos;
	#pos =&(L.elem[L.length-1]);
	#[Keywords]for#(++p; p<=pos; ++p){
		#[Tags]*(p-1) = #[Tags]*p;
	#}
	#--L.length;
	#[Keywords]return #OK;
#}
#end#[Keywords]if #[Comments]//SQLIST_H
#[Keywords]int #main(){
	#SqList list;
	#ElemType e;
	#InitList(list);
	#ListInsert(list, 1, 1);
	#ListInsert(list, 2, 2);
	#ListInsert(list, 3, 3);
	#ListInsert(list, 4, 4);
	#ListInsert(list, 5, 5);
	#[Keywords]for#(#[Keywords]int #i =0; i<list.length; i++){
		#printf(#[Fields]"%d\n"#,list.elem[i]);
	#}
	#ListDelete(list, 2, e);
	#[Keywords]for#(i =0; i<list.length; i++){
		#printf(#[Fields]"%d\n"#,list.elem[i]);
	#}	printf(#[Fields]"%d\n"#, list.length);
	
	#[Keywords]return #1;
#}
[/code]