代码如下：
[code=java]
#include <stdio.h>
#define MAX 255
#[Keywords]int #R[MAX];
#[Keywords]void #Heapify(#[Keywords]int #s,#[Keywords]int #m)
{ #[Tags]/*对R[1..n]进行堆调整，用temp做暂存单元 */
     #[Keywords]int #j,temp;
     #temp=R[s];
     #j=2*s;
     #[Keywords]while #(j<=m)
     #{
	  #[Keywords]if #(R[j]>R[j+1]&&j<m) j++;
	  #[Keywords]if #(temp<R[j]) #[Keywords]break#;
	  #R[s]=R[j];
          #s=j;
          #j=j*2;
     #}#[Tags]/* end of #[Keywords]while #*/
     #R[s]=temp;
#} #[Tags]/* end of Heapify */
#[Keywords]void #BuildHeap(#[Keywords]int #n)
{ #[Tags]/* 由一个无序的序列建成一个堆 */
   #[Keywords]int #i;
   #[Keywords]for#(i=n/2;i>0;i--)
      #Heapify(i,n);
#}
#[Keywords]void #Heap_Sort(#[Keywords]int #n)
{ #[Tags]/* 对R[1..n]进行堆排序，不妨用R[0]做暂存单元 */
    #[Keywords]int #i;
    #BuildHeap(n); #[Tags]/* 将R[1-n]建成初始堆 */
    #[Keywords]for#(i=n;i>1;i--)
    #{ #[Tags]/* 对当前无序区R[1..i]进行堆排序，共做n-1趟。 */
    	#R[0]=R[1]; R[1]=R[i];R[i]=R[0]; #[Tags]/* 将堆顶和堆中最后一个记录交换 */
    	#Heapify(1,i-1); #[Tags]/* 将R[1..i-1]重新调整为堆，仅有R[1]可能违反堆性质 */
    #} #[Tags]/* end of #[Keywords]for #*/
#} #[Tags]/* end of Heap_Sort */
#[Keywords]void #main()
{
	#[Keywords]int #i,n;
	#clrscr();
	#puts(#[Fields]"Please input total element number of the sequence:"#);
	#scanf(#[Fields]"%d"#,&n);
	#[Keywords]if#(n<=0||n>MAX)
	#{
		#printf(#[Fields]"n must more than 0 and less than %d.\n"#,MAX);
		#exit(0);
	#}
	#puts(#[Fields]"Please input the elements one by one:"#);
	#[Keywords]for#(i=1;i<=n;i++)
		#scanf(#[Fields]"%d"#,&R[i]);
	#puts(#[Fields]"The sequence you input is:"#);
	#[Keywords]for#(i=1;i<=n;i++)
		#printf(#[Fields]"%4d"#,R[i]);
	#Heap_Sort(n);
	#puts(#[Fields]"\nThe sequence after Big heap_sort is:"#);
	#[Keywords]for#(i=1;i<=n;i++)
		#printf(#[Fields]"%4d"#,R[i]);
	#puts(#[Fields]"\n Press any key to quit..."#);
	#getch();
#}
[/code]