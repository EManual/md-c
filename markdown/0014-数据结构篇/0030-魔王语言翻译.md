代码如下：
[code=java]
#include   <stdio.h> 
#include   <string.h> 
#include   <stdlib.h> 
#include   <conio.h> 
#[Tags]/*定义全局变量*/ 
#define   TRUE   1 
#define   FALSE   0 
#define   OK   1 
#define   ERROR   0 
#define   NULL   0 
#define   OVERFLOW   -2 
#define   MAXSIZE   100 
#define   stack_init_size   100 
#define   stackincrement   10 
typedef   #[Keywords]char #  selemType; 
typedef   #[Keywords]char #  qelemType; 
typedef   #[Keywords]char #  elemType; 
typedef   #[Keywords]int #  status; 
#[Keywords]char #  e;     
#[Keywords]char #  demon[MAXSIZE];
#[Tags]/* 类型及其基本操作*/   
typedef   struct   
{   
	#selemType   *base;
	#selemType   *top;
	#[Keywords]int #  stacksize; 
#}sqstack;     
status   initstack   (sqstack   *s) 
{     
	#s->base=(selemType   *)malloc(stack_init_size*sizeof(selemType));
	#[Keywords]if#(!s->base)   exit   (OVERFLOW); 
	#s->top=s->base;
	#s->stacksize=stack_init_size;
	#[Keywords]return #  OK; 
#}#[Tags]/*创建栈*/ 
status   push   (sqstack   *s,selemType   e) 
{ 
	#[Keywords]if#(s->top-s->base>=s->stacksize) 
	#{
		#s->base=(elemType*)   realloc(s->base,(s->stacksize+stackincrement)*sizeof(elemType))
		#[Keywords]if#(!s->base)   exit(OVERFLOW); 
		#s->top=s->base+s->stacksize;
		#s->stacksize+=stackincrement;
	#} 
	#[Tags]*(s->top++)=e; 
	#[Keywords]return #  OK; 
#}#[Tags]/*入栈*/ 
status   pop(sqstack   *s,selemType   *e) 
{     
	#[Keywords]if#(s->top==s->base)   #[Keywords]return #  ERROR; 
	#[Tags]*e=#[Tags]*(--(s->top)); 
	#[Keywords]return #  OK; 
#}#[Tags]/*出栈*/ 
#[Tags]/*队列类型及其基本操作*/ 
typedef   struct   qnode 
{ 
	#qelemType   data;
	#struct   qnode   *next;
#}qnode,*queueptr; 
typedef   struct 
{ 
	#queueptr   front;
	#queueptr   rear;
#}linkqueue; 
status   initqueue(linkqueue   *q) 
{ 
	#q->front=q->rear=(queueptr)malloc(sizeof(qnode));
	#[Keywords]if#(!q->front)   exit(OVERFLOW); 
	#q->front->next=NULL;
	#[Keywords]return #  OK; 
#}#[Tags]/*创建队列*/ 
status   enqueue(linkqueue   *q,qelemType   e) 
{ 
	#queueptr   p;
	#p=(queueptr)malloc(sizeof(qnode));
	#[Keywords]if#(!p)   exit(OVERFLOW); 
	#p->data=e;
	#p->next=NULL;
	#q->rear->next=p;
	#q->rear=p;
	#[Keywords]return #  OK; 
#}#[Tags]/*入队*/ 
status   dequeue(linkqueue   *q,qelemType   *e) 
{ 
	#queueptr   p;
	#[Keywords]if#(q->front==q->rear)   #[Keywords]return #  ERROR; 
	#p=q->front->next;
	#[Tags]*e=p->data; 
	#q->front->next=p->next;
	#[Keywords]if#(q->rear==p) 
	#{
		#q->rear=q->front;
	#} 
	#free(p);
	#[Keywords]return #  OK;
#}#[Tags]/*出队*/ 
 #/*括号内元素入栈处理函数*/
#[Keywords]void #  tempstack(sqstack   *temps) 
{ 
	#[Keywords]int #  i=0; 
	#[Keywords]char #  t; 
	#[Keywords]char #  c;
	#c=demon[i];
	#[Keywords]for#(i=0;c!=#[Fields]'#'#;i++)/*遍历数组*/
	#{
		#c=demon[i];
		#[Keywords]if#(c==#[Fields]'('#)/*遇到开括号*/
		#{
			#t=demon[i+1];/*取括号中的首字母*/
			#push(temps,t);/*入栈*/
			#i++;/*指向首字母*/
			#[Keywords]do #
			#{
				#i++;
				#c=demon[i];
				#push(temps,c)#[Tags]/*第一次循环将次字母入栈*/;
				#push(temps,t);#[Tags]/*再将首字母进栈*/
			#}#[Keywords]while#(c!=#[Fields]')'#);#[Tags]/*直到括号中元素全部进栈*/ 
			#pop(temps,&t);#[Tags]/*将多余进栈的首字母t出栈*/
			#pop(temps,&t);   #[Tags]/*将多余进栈的#[Fields]')'#出栈*/
		#} 
	#} 
#}#[Tags]/*临时栈*/ 
#[Tags]/*特殊入队函数*/
#[Keywords]void #  spenqueue(linkqueue   *q,#[Keywords]char #  key)     
{     
	#[Keywords]int #  j=0;
	#[Keywords]char #  a[5]; 
	#switch(key)   /*判断大写字母对应的字符串*/
	#{
	#case#[Fields]'A'#:strcpy(a,#[Fields]"ase"#);#[Keywords]break#;
	#case#[Fields]'B'#:strcpy(a,#[Fields]"tAdA"#);#[Keywords]break#;
	#case#[Fields]'C'#:strcpy(a,#[Fields]"abc"#);#[Keywords]break#;
	#case#[Fields]'D'#:strcpy(a,#[Fields]"def"#);#[Keywords]break#;
	#case#[Fields]'E'#:strcpy(a,#[Fields]"ghi"#);#[Keywords]break#;
	#case#[Fields]'F'#:strcpy(a,#[Fields]"klm"#);#[Keywords]break#;
	#case#[Fields]'H'#:strcpy(a,#[Fields]"mop"#);#[Keywords]break#;
	#[Keywords]default#:strcpy(a,#[Fields]"???"#);   /*不能翻译的魔王语言以#[Fields]"???"#输出*/ 
	#} 
	#[Keywords]while#(a[j]!=#[Fields]'\0'#)   /*如果数组还有字母*/ 
	#{
		#enqueue(q,a[j]);/*进队*/
		#j++;
	#} 
#}/*特殊入队*/ 
/*排序入队处理函数*/ 
status   sort(sqstack   *s,linkqueue   *q) 
{     
	#qnode   b;
	#[Keywords]int #  flag=0;/*大写字母监视哨置零*/ 
	#[Keywords]int #  i; 
	#[Keywords]for#(i=0;demon[   i]!=#[Fields]'#'#;i++)/*遍历数组*/ 
	#{
		#b.data=demon[   i];
		#[Keywords]if#(   (#[Fields]'a'#<=b.data&&b.data<=#[Fields]'z'#)||b.data==#[Fields]'?'#)   
		#[Tags]/*如果是小写字母或者#[Fields]'?'#　则直接进栈*/     
		#{
			#enqueue(q,b.data);
		#} 
		#[Keywords]else #
		#{
			#[Keywords]if#(#[Fields]'A'#<=b.data&&b.data<=#[Fields]'Z'#)   #[Tags]/*如果是大写字母,则调用特殊进栈函数,*/     
			#{
				#spenqueue(q,b.data);
				#flag=1;   #[Tags]/*发现大写字母监视哨置1*/
			#} 
			#[Keywords]else #
			#{
				#[Keywords]if#(b.data==#[Fields]'('#)/*如果是括号*/ 
				#{
					#[Keywords]do #
					#{
						#pop(s,&e);
						#enqueue(q,e);
					#}#[Keywords]while#(!(s->top==s->base));   #[Tags]/*只要栈不为空,则出栈进队*/     
					#[Keywords]while #  (b.data!=#[Fields]')'#)   
					#[Tags]/*只要还指向括号内元素,就继续往后移,保证原括号内的元素不再进栈*/ 
					#{
						#i++;
						#b.data=demon[i];
					#} 
				#} 
			#} 
		#} 
	#}
	#[Keywords]return #  flag; 
#}#[Tags]/*排序*/
#[Tags]/*主函数*/
status   main() 
{ 
	#sqstack   s1;
	#linkqueue   q1;
	#[Keywords]int #  k=0; 
	#[Keywords]int #  flag=1; 
	#clrscr();
	#printf(#[Fields]"Please   Input   the   Demon#[Fields]'s   Words:\n"#);
	#printf(#[Fields]"!:   Less   Than   30   Letters:   )\n"#);
	#printf(#[Fields]"!:   End   with   #[Fields]'#'#:   )\n\t"#);
	#scanf(#[Fields]"%s"#,demon);
	#printf(#[Fields]"\n***************************************"#);
	#initstack(&s1);   #[Tags]/*创建栈*/
	#initqueue(&q1);   #[Tags]/*创建队*/
	#tempstack(&s1);   #[Tags]/*调用函数*/
	#[Keywords]while #  (flag==1)   #[Tags]/*如果有大写字母*/ 
	#{
		#k=0;
		#flag=sort(&s1,&q1);
		#[Keywords]while#(q1.front!=q1.rear)   #[Tags]/*重写demon[i   ]*/ 
		#{
			#dequeue(&q1,&e);
			#demon[k]=e;
			#k++;
		#}
		#demon[k]=#[Fields]'#'#;
	#}
	#demon[k]=#[Fields]'\0'#;
	#printf(#[Fields]"\n***************************************"#);
	#printf(#[Fields]"\nThe   Human   Words:\n\t%s"#,demon);
	#printf(#[Fields]"\n***************************************"#);
#}
[/code]