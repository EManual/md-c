代码如下：
[code=java]
#include <stdio.h>
#define CHILDREN 5
struct person{
	#[Keywords]char #*name;#[Tags]/*名字符串指针*/
	#[Keywords]char #sex;#[Tags]/*性别：男用字符#[Fields]'M'#；女用字符#[Fields]'F'#*/
	#struct person *father;#[Tags]/*指向父亲*/
	#struct person *mother;#[Tags]/*指向母亲*/
	#struct person *mate;#[Tags]/*指向配偶*/
	#struct person *children[CHILDREN];#[Tags]/*指向子女*/
#};
#[Tags]/* [函数]newperson增加新人 */
struct person *newperson(#[Keywords]char #*name,#[Keywords]char #sex)
{
	#struct person *p;
	#[Keywords]int #index;
	#p=(struct person *)malloc(sizeof(struct person));
	#p->name=(#[Keywords]char #*)malloc(strlen(name)+1);
	#strcpy(p->name,name);
	#p->sex=sex;
	#p->father=NULL;
	#p->mother=NULL;
	#p->mate=NULL;
	#[Keywords]for#(index=0;index<CHILDREN;index++)
		#p->children[index]=NULL;
	#[Keywords]return #p;
#}
#[Tags]/* [函数]father_child建立父－子关系 */
father_child(struct person *father,struct person *child)
{
	#[Keywords]int #index;
	#[Keywords]for#(index=0;index<CHILDREN-1;index++)#[Tags]/*寻找一个空缺的子女指针*/
		#[Keywords]if#(father->children[index]==NULL)#[Tags]/*若没有空缺，则填在最后*/
			#[Keywords]break#;
	#father->children[index]=child;#[Tags]/*建立父－子关系*/
	#child->father=father;
#}
#[Tags]/* [函数]mother_child建立母－子关系 */
mother_child(struct person *mother,struct person *child)
{
	#[Keywords]int #index;
	#[Keywords]for#(index=0;index<CHILDREN-1;index++)#[Tags]/*寻找一个空缺的子女指针*/
		#[Keywords]if#(mother->children[index]==NULL)#[Tags]/*若没有空缺，则填在最后*/
			#[Keywords]break#;
	#mother->children[index]=child;#[Tags]/*建立母－子关系*/
#}
#[Tags]/* [函数]mate 建立配偶关系 */
mate(struct person *h,struct person *w)
{
	#h->mate=w;/*建立配偶关系*/
	#w->mate=h;
#}
#[Tags]/* [函数]brotherinlow 检查两人是否是堂兄妹 */
#[Keywords]int #brothersinlaw(struct person *p1,struct person *p2)
{
	#struct person *f1,*f2;
	#[Keywords]if#(p1==NULL||p2==NULL||p1==p2) #[Keywords]return #0;
	#[Keywords]if#(p1->sex==p2->sex) #[Keywords]return #0;#[Tags]/*不可能是堂兄妹*/
	#f1=p1->father;
	#f2=p2->father;
	#[Keywords]if#(f1!=NULL&&f1==f2) #[Keywords]return #0;#[Tags]/*是兄妹，不是堂兄妹*/
	#[Keywords]while#(f1!=NULL&&f2!=NULL&&f1!=f2)#[Tags]/*考虑远房情况*/
	#{
		#f1=f1->father;
		#f2=f2->father;
		#[Keywords]if#(f1!=NULL&&f2!=NULL&&f1==f2) #[Keywords]return #1;
	#}
	#[Keywords]return #0;
#}
#[Tags]/* 函数print_relate用于输出人物p的姓名，性别和各种关系 */
#[Keywords]void #print_relate(struct person *p)
{
	#[Keywords]int #index,i;
	#[Keywords]if#(p->name==NULL)
		#[Keywords]return#;#
	#[Keywords]if#(p->sex==#[Fields]'M'#)
		#printf(#[Fields]" %s is male."#,p->name);
	#else
		#printf(#[Fields]" %s is female."#,p->name);
	#[Keywords]if#(p->father!=NULL)
		#printf(#[Fields]" %s#[Fields]'s father is %s."#,p->name,p->father->name);
	#[Keywords]if#(p->mother!=NULL)
		#printf(#[Fields]" %s#[Fields]'s mother is %s."#,p->name,p->mother->name);
	#printf(#[Fields]"\n"#);
	#[Keywords]if#(p->mate!=NULL)
		#[Keywords]if#(p->sex==#[Fields]'M'#)
			#printf(#[Fields]" His wife is %s."#,p->mate->name);
		#else
			#printf(#[Fields]" Her husband is %s."#,p->mate->name);
	#[Keywords]if#(p->children!=NULL)
	#{	#[Keywords]for#(index=0;index<CHILDREN-1;index++)#[Tags]/*寻找一个空缺的子女指针*/
		#[Keywords]if#(p->children[index]==NULL)#[Tags]/*若没有空缺，index为子女个数 */
			#[Keywords]break#;
		#[Keywords]if#(index>0)
			#printf(#[Fields]" Children are:"#);
		#[Keywords]for#(i=0;i<index;i++)
			#printf(#[Fields]" %s"#,p->children[i]->name);
	#}
	#printf(#[Fields]"\n"#);
#}
main()
{
	#[Keywords]char #*name[8]={#[Fields]"John"#,#[Fields]"Kate"#,#[Fields]"Maggie"#,#[Fields]"Herry"#,#[Fields]"Jason"#,#[Fields]"Peter"#,#[Fields]"Marry"#,#[Fields]"Jenny"##};
	#[Keywords]char #male=#[Fields]'M'#,female=#[Fields]'F'#;
	#struct person *pGrandfather,*pFather1,*pFather2,*pMother1,*pMother2,*pSon,*pDaughter,*pCousin;
	#clrscr();
	#pGrandfather = newperson(name[0],male);
	#pFather1 = newperson(name[3],male);
	#pFather2 = newperson(name[4],male);
	#pMother1 = newperson(name[1],female);
	#pMother2 = newperson(name[2],female);
	#pSon = newperson(name[5],male);
	#pDaughter = newperson(name[6],female);
	#pCousin = newperson(name[7],female);
	#father_child(pGrandfather,pFather1);
	#father_child(pGrandfather,pFather2);
	#father_child(pFather1,pSon);
	#father_child(pFather1,pDaughter);
	#father_child(pFather2,pCousin);
	#mate(pFather1,pMother1);
	#mate(pFather2,pMother2);
	#mother_child(pMother1,pSon);
	#mother_child(pMother1,pDaughter);
	#mother_child(pMother2,pCousin);
	#[Tags]/* 输出各种关系 */
	#print_relate(pGrandfather);
	#print_relate(pFather1);
	#print_relate(pFather2);
	#print_relate(pMother1);
	#print_relate(pMother2);
	#print_relate(pSon);
	#print_relate(pDaughter);
	#print_relate(pCousin);
	#[Keywords]if#(!brothersinlaw(pDaughter,pCousin))
		#printf(#[Fields]"%s and %s are not brothers (sisters) in law.\n"#,pDaughter->name,pCousin->name);
	#else
		#printf(#[Fields]"%s and %s are brothers (sisters) in law.\n"#,pDaughter->name,pCousin->name);
	#[Keywords]if#(!brothersinlaw(pSon,pCousin))
		#printf(#[Fields]"%s and %s are not brothers (sisters) in law.\n"#,pSon->name,pCousin->name);
	#else
		#printf(#[Fields]"%s and %s are brothers (sisters) in law.\n"#,pSon->name,pCousin->name);
	#[Keywords]if#(!brothersinlaw(pSon,pDaughter))
		#printf(#[Fields]"%s and %s are not brothers (sisters) in law.\n"#,pSon->name,pDaughter->name);
	#else
		#printf(#[Fields]"%s and %s are brothers (sisters) in law.\n"#,pSon->name,pDaughter->name);

	#puts(#[Fields]"\n Press any key to quit..."#);
	#getch();
#}
[/code]